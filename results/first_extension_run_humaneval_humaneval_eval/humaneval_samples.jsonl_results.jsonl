{"task_id": "HumanEval/163", "completion": "def generate_integers(a, b):\n    start, end = min(a, b), max(a, b)\n    result = []\n    for num in range(start, end + 1):\n        if all(int(digit) % 2 == 0 for digit in str(num)):\n            result.append(num)\n    return result", "result": "failed: Test 3", "passed": false}
{"task_id": "HumanEval/28", "completion": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)", "result": "passed", "passed": true}
{"task_id": "HumanEval/6", "completion": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    lst = sorted(lst)\n    result = []\n    left, right = 0, len(lst) - 1\n    toggle = True\n    while left <= right:\n        if toggle:\n            result.append(lst[left])\n            left += 1\n        else:\n            result.append(lst[right])\n            right -= 1\n        toggle = not toggle\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/62", "completion": "def derivative(xs: list):\n    return [i * xs[i] for i in range(1, len(xs))]", "result": "passed", "passed": true}
{"task_id": "HumanEval/57", "completion": "def monotonic(l: list):\n    return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))", "result": "passed", "passed": true}
{"task_id": "HumanEval/35", "completion": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n    max_val = l[0]\n    for item in l[1:]:\n        if item > max_val:\n            max_val = item\n    return max_val", "result": "passed", "passed": true}
{"task_id": "HumanEval/26", "completion": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "result": "passed", "passed": true}
{"task_id": "HumanEval/139", "completion": "def special_factorial(n):\n    from math import factorial\n    result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/22", "completion": "def filter_integers(values: List[Any]) -> List[int]:\n    return [v for v in values if isinstance(v, int)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/151", "completion": "def double_the_difference(lst):\n    return sum(x**2 for x in lst if isinstance(x, int) and x >= 0 and x % 2 == 1)", "result": "passed", "passed": true}
{"task_id": "HumanEval/108", "completion": "def count_nums(arr):\n    def sum_signed_digits(n):\n        s = str(n)\n        total = 0\n        if s[0] == '-':\n            total += -int(s[1])\n            for ch in s[2:]:\n                total += int(ch)\n        else:\n            for ch in s:\n                total += int(ch)\n        return total\n\n    count = 0\n    for num in arr:\n        if sum_signed_digits(num) > 0:\n            count += 1\n    return count", "result": "passed", "passed": true}
{"task_id": "HumanEval/8", "completion": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    total_sum = 0\n    total_product = 1\n    for num in numbers:\n        total_sum += num\n        total_product *= num\n    return total_sum, total_product", "result": "passed", "passed": true}
{"task_id": "HumanEval/7", "completion": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "result": "passed", "passed": true}
{"task_id": "HumanEval/23", "completion": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    count = 0\n    for _ in string:\n        count += 1\n    return count", "result": "passed", "passed": true}
{"task_id": "HumanEval/55", "completion": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a", "result": "passed", "passed": true}
{"task_id": "HumanEval/59", "completion": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1 if factor == 2 else 2\n        if factor * factor > n and n > 1:\n            last_factor = n\n            break\n    return last_factor", "result": "passed", "passed": true}
{"task_id": "HumanEval/129", "completion": "from collections import deque\n\ndef minPath(grid, k):\n    N = len(grid)\n    pos = [None] * (N * N + 1)\n    for r in range(N):\n        for c in range(N):\n            pos[grid[r][c]] = (r, c)\n\n    # Directions for neighbors (up, down, left, right)\n    dirs = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    # We want to find the lex smallest path of length k\n    # starting from any cell.\n\n    # Idea:\n    # Since all numbers are unique and from 1 to N*N,\n    # we can consider the values as priorities.\n    # At each step, from the current cell,\n    # we explore neighbors and pick the lex smallest next cell value.\n    # Since path can revisit cells, but lex order matters,\n    # we need to pick the minimal next step at each step.\n    #\n    # But we need to consider that the minimal path might start anywhere.\n    # So we try all cells as start and pick the lex smallest path.\n    #\n    # However, k can be large. A brute force search may be costly.\n    #\n    # Optimization:\n    # We can do a BFS with states (r, c, length)\n    # and keep track of the lex smallest path to reach that state.\n    #\n    # But to keep it efficient, use a priority queue and always\n    # expand the lex smallest partial path first.\n    #\n    # Since k can be large, we use a BFS with pruning:\n    # - use a dictionary to store the lex smallest path to (r,c,l)\n    # - expand states with lex smallest path first.\n\n    from heapq import heappush, heappop\n\n    # Each state: (path as tuple), r, c, length\n    heap = []\n    visited = dict()\n\n    # Initialize heap with all starting positions\n    for r in range(N):\n        for c in range(N):\n            val = grid[r][c]\n            path = (val,)\n            heappush(heap, (path, r, c, 1))\n            visited[(r,c,1)] = path\n\n    while heap:\n        path, r, c, length = heappop(heap)\n        if length == k:\n            return list(path)\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < N and 0 <= nc < N:\n                nval = grid[nr][nc]\n                npath = path + (nval,)\n                state = (nr, nc, length + 1)\n                if state not in visited or npath < visited[state]:\n                    visited[state] = npath\n                    heappush(heap, (npath, nr, nc, length + 1))", "result": "passed", "passed": true}
{"task_id": "HumanEval/161", "completion": "def solve(s):\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join(c.swapcase() if c.isalpha() else c for c in s)", "result": "passed", "passed": true}
{"task_id": "HumanEval/143", "completion": "def words_in_sentence(sentence):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return \" \".join(prime_length_words)", "result": "passed", "passed": true}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "result": "passed", "passed": true}
{"task_id": "HumanEval/155", "completion": "def even_odd_count(num):\n    num_str = str(abs(num))\n    even_count = sum(1 for digit in num_str if int(digit) % 2 == 0)\n    odd_count = len(num_str) - even_count\n    return (even_count, odd_count)", "result": "passed", "passed": true}
{"task_id": "HumanEval/107", "completion": "def even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "result": "passed", "passed": true}
{"task_id": "HumanEval/56", "completion": "def correct_bracketing(brackets: str):\n    count = 0\n    for char in brackets:\n        if char == '<':\n            count += 1\n        else:\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "result": "passed", "passed": true}
{"task_id": "HumanEval/114", "completion": "def minSubArraySum(nums):\n    min_ending_here = min_so_far = nums[0]\n    for num in nums[1:]:\n        min_ending_here = min(num, min_ending_here + num)\n        min_so_far = min(min_so_far, min_ending_here)\n    return min_so_far", "result": "passed", "passed": true}
{"task_id": "HumanEval/71", "completion": "def triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return round(area, 2)", "result": "passed", "passed": true}
{"task_id": "HumanEval/1", "completion": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    groups = []\n    balance = 0\n    start = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if balance == 0:\n                start = i\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                groups.append(paren_string[start:i+1])\n    return groups", "result": "passed", "passed": true}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list):\n    n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False", "result": "passed", "passed": true}
{"task_id": "HumanEval/152", "completion": "def compare(game, guess):\n    return [abs(g - gs) for g, gs in zip(game, guess)]", "result": "passed", "passed": true}
{"task_id": "HumanEval/87", "completion": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort(key=lambda c: (c[0], -c[1]))\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/138", "completion": "def is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    return n % 2 == 0", "result": "passed", "passed": true}
{"task_id": "HumanEval/39", "completion": "def prime_fib(n: int):\n    def is_prime(x):\n        if x < 2:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    a, b = 0, 1\n    count = 0\n    while True:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "result": "passed", "passed": true}
{"task_id": "HumanEval/148", "completion": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    i1, i2 = planets.index(planet1), planets.index(planet2)\n    start, end = sorted([i1, i2])\n    return tuple(planets[start+1:end])", "result": "passed", "passed": true}
{"task_id": "HumanEval/86", "completion": "def anti_shuffle(s):\n    result = []\n    word = []\n    for char in s:\n        if char != ' ':\n            word.append(char)\n        else:\n            if word:\n                sorted_word = ''.join(sorted(word))\n                result.append(sorted_word)\n                word = []\n            result.append(' ')\n    if word:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    return ''.join(result)", "result": "passed", "passed": true}
{"task_id": "HumanEval/156", "completion": "def int_to_mini_roman(number):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syms[i]\n            number -= val[i]\n        i += 1\n    return roman_num.lower()", "result": "passed", "passed": true}
{"task_id": "HumanEval/149", "completion": "def list_sort(lst):\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    return sorted(filtered, key=lambda x: (len(x), x))", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/97", "completion": "def multiply(a, b):\n    return (abs(a) % 10) * (abs(b) % 10)", "result": "passed", "passed": true}
{"task_id": "HumanEval/12", "completion": "def longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)", "result": "passed", "passed": true}
{"task_id": "HumanEval/45", "completion": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * a * h", "result": "passed", "passed": true}
{"task_id": "HumanEval/135", "completion": "def can_arrange(arr):\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1", "result": "passed", "passed": true}
{"task_id": "HumanEval/44", "completion": "def change_base(x: int, base: int):\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x //= base\n    return ''.join(digits[::-1])", "result": "passed", "passed": true}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    if a == 0:\n        return True\n    root = round(abs(a) ** (1/3))\n    return root**3 == abs(a) if a >= 0 else -root**3 == a", "result": "passed", "passed": true}
{"task_id": "HumanEval/33", "completion": "def sort_third(l: list):\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_vals = sorted(l[i] for i in indices)\n    result = l[:]\n    for idx, val in zip(indices, sorted_vals):\n        result[idx] = val\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/103", "completion": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    avg = round((n + m) / 2)\n    return bin(avg)", "result": "passed", "passed": true}
{"task_id": "HumanEval/5", "completion": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(delimeter)\n        result.append(num)\n    return result", "result": "passed", "passed": true}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    vowels = 'aeiou'\n    result = []\n    for ch in message:\n        if ch.isalpha():\n            swapped = ch.swapcase()\n            lower = swapped.lower()\n            if lower in vowels:\n                # Find the vowel's position and replace with letter 2 places ahead\n                new_char = chr(((ord(lower) - ord('a') + 2) % 26) + ord('a'))\n                # preserve case after swapcase (which swapped original case)\n                if swapped.isupper():\n                    new_char = new_char.upper()\n                result.append(new_char)\n            else:\n                result.append(swapped)\n        else:\n            result.append(ch)\n    return ''.join(result)", "result": "passed", "passed": true}
{"task_id": "HumanEval/58", "completion": "def common(l1: list, l2: list):\n    return sorted(set(l1) & set(l2))", "result": "passed", "passed": true}
{"task_id": "HumanEval/68", "completion": "def pluck(arr):\n    min_value = None\n    min_index = None\n    for i, val in enumerate(arr):\n        if val % 2 == 0:\n            if min_value is None or val < min_value or (val == min_value and i < min_index):\n                min_value = val\n                min_index = i\n    return [min_value, min_index] if min_value is not None else []", "result": "passed", "passed": true}
{"task_id": "HumanEval/15", "completion": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n+1))", "result": "passed", "passed": true}
{"task_id": "HumanEval/48", "completion": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "result": "passed", "passed": true}
